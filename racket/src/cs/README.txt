Work-in-progress for running Racket on Chez Scheme.


Requirements:

 * Chez Scheme --- for now, use a fork at

      https://github.com/mflatt/ChezScheme

   but we will eventually return to the current development version
   from

      https://github.com/cisco/ChezScheme

   If this build of Chez Scheme is not installed so that plain
   `scheme` on the command line runs your installation, you can use
   `make SCHEME=...` to set the command for `scheme`.

 * Racket --- a recent version

   By default, `make` will use the enclosing Racket build. Go back to
   the root of this repository/distribution and build so that at least
   the "compiler-lib" and "parser-tools-lib" packages are installed,
   either with just `make` (for a full build) or with

      make PKGS="compiler-lib parser-tools-lib"

   If you'd like to use an existing installation of Racket, instead,
   you can use `make RACKET=...` to set the command for `racket`.


Building:

Running `make` will build the Racket-on-Chez implementation. Use `make
expander-demo` to run a demo that loads `racket/base` from source.

Use `make setup` to try to build ".zo" files for collection-based
libraries. Compilation should get theough the main "collects"
directory without errors, and building packages will likely encounter
errors. (The `make setup` step is useful to at least get the
`racket/base` and `racket` built.) Each ".zo" file is written to a
subdirectory of "compiled" where the subdirectory name corresponds to
the Chez Scheme platform name (e.g., "a6osx"), and the content of the
".zo" file is platform-specific code generated by the Chez Scheme
compiler.

If you want to control the `raco setup` that `make setup` runs, supply
an `ARGS` variable to make, such as

   make setup ARGS="-l typed/racket"  # only sets up TR
   make setup ARGS="--clean -Dd"      # clears ".zo" files
   make setup ARGS="--fail-fast"      # stop at the first error


Running:

Use `make run ARGS="..."` to run Racket on Chez Scheme analogous to
running plain `racket`, where command-line arguments are supplied in
`ARGS`. Only some of the normal `racket` command-line arguments are
supported currently.


Structure:

The reimplementation on Chez Scheme is meant to export the same
interface as the traditional Racket virtual machine (in "../racket").
The most primitive pieces of the bridge are implemented in the
"core.sls" library, which is implemented directly in Chez Scheme. The
rest builds up in layers, each of which is implemented in Racket:

   thread
   io
   regexp
   expander

Each but the last of those layers is implemented in a sibling
directory of this one. The "expander" layer's implementation is in
"../../../pkgs" (because it's useful as a standalone Racket package).

Although the "thread" layer is implemented in Racket, in its fully
expanded form it must not refer to any functionality of "io",
"regexp", or "expander", while the expanded form of "io" must not
refer to "regexp" or "expander" functionality, and so on. Each layer
can use `racket/base` functionality, but beware that code from
`racket/base` will be duplicated in each layer.

The "io" layer relies on a shared library, rktio, to provide a uniform
interface to OS resources. The rktio source is in a "rktio" sibling
directory.

Files in this directory:

 *.sls - Chez Scheme libraries that provide implementations of Racket
         primitives, building up to the Racket expander. The
         "core.sls" library is implemented directly in Chez Scheme.
         For most other cases, a corresponding "compiled/*.scm" file
         contains the implementation extracted from from expanded and
         flattened Racket code. Each "*.sls" file is built to "*.so".

 core/*.ss - Part of "core.sls" (via `include`) to implement core data
         structures, immutable hash tables, structs, etc.

 *.scm - a temporary compatibility layer to be `include`d into an
         ".sls" library.

 compiled/*.scm (generated) - A conversion from a ".rktl" file to be
         `included`d into an ".sls" library.

 ../*/compiled/*.rktl (generated) - A Racket library (e.g., to
         implement regexps) that has been fully macro expanded and
         flattened into a linklet from its source in "../*". A
         linklet's only free variables are primitives that will be
         implemented by various ".sls" libraries in lower layers.

         For example, "../thread" contains the implementation (in
         Racket) of the thread and event subsystem.

         CAUTION: The makefile here doesn't track dependencies for
         "*.rktl" files for any target except the default `make`
         target. Run `make rktl` if you change any of those
         implementations when using a target other than the default.

 ../build/so-rktio/rktio.rktl (generated) and
 ../../lib/librktio.{so,dylib,dll} (generated) - Created when building
         the "io" layer, the "rktio.rktl" file contains FFI descriptions
         that are `included` by "io.sls" and "librktio.{so,dylib,dll}"
         is the shared library that implements rktio.

         CAUTION: The makefile here doesn't track dependencies for
         rktio, so use `make rktio` if you change its implementation.

 primitive/*.scm - for "expander.sls", tables of bindings for
         primitive linklet instances.

 convert.rkt - A linklet-to-library-body compiler, which is used to
         convert a ".rktl" file to a ".scm" file to inclusion in an
         ".sls" library.

 demo/*.ss - Chez Scheme scripts to check that a library basically
         works. For example "demo/regexp.ss" runs the regexp matcher
         on a few examples. To run "demo/*.ss", use `make *-demo`.

 schemify/schemify.rkt - Source of "compiled/schemify.scm", which is
         part of the implementation of linklets --- specifically, for
         compiling a Racket linklet to a Chez Scheme procedure.

 other *.rkt - Racket scripts like "convert.rkt" or comparisions like
         "demo/regexp.rkt". For example, you can run "demo/regexp.rkt"
         and compare the reported timing to "demo/regexp.ss".


Running "demo/expander.ss":

 A `make expander-demo` builds and tries the expander on simple
 examples, including loading `racket/base` from source.


Dumping linklets and schemified linklets:

 Set the `PLT_LINKLET_SHOW` environment variable to pretty print each
 linklet generated by the expander and its schemified form that is
 passed on to Chez Scheme.


Development mode:

 If you make changes to file in "core", you should turn off
 `[CORE_]UNSAFE_COMP` in the makefile.


Status and thoughts on various Racket subsystems:

 * Applicable structs work by adding an indirection to each function
   call when the target is not obviously a plain procedure; with the
   analysis in "schemify/schemify.rkt", the indirection is not needed
   often in a typical program, and the overhead appears to be light
   when it is needed.

 * Racket's delimited continuations, continuation marks, threads, and
   events are mostly in place (see "core/control.ss",
   "core/engine.ss", and the source for "thread.rktl").

 * The "rktio" library fills the gap between Racket and Chez Scheme's
   native I/O. The "rktio" library provides a minimal, non-blocking,
   non-GCed interface to OS-specific functionality. Its' compiled to a
   shared library and loadied into Chez Scheme, and then Racket's I/O
   API is implemented in Racket by calling rktio as a kind of foreign
   library.

 * The Racket FFI looks a lot like the Chez Scheme FFI, so I expect
   that to mostly work, although there may be allocation issues.

 * The Racket and Chez Scheme numeric systems likely differ in some
   ways, and I don't know how much work that will be.

 * For futures, Chez Scheme exposes OS-level threads with limited
   safety guarantees. An implementation of futures can probably take
   advantage of threads with thread-unsafe primitives wrapped to
   divert to a barrier when called in a future.

 * GC-based memory accounting similarly seems to require new support,
   but that can wait a while.

 * Extflonums will probably exist only on the Racket VM for a long
   while.

 * For now, `make setup` builds platform-specific ".zo" files in a
   subdirectory of "compiled" named by the Chez Scheme platform name
   (e.g., "a6osx"). Longer term, although bytecode as it currently
   exists goes away, platform-independent ".zo" files might contain
   fully expanded source (possibly also run through Chez Scheme's
   source-to-source optimizer) with `raco setup` gaining a new step in
   creating platform-specific compiled code.


Performance notes:

The best-case scenario for performance is

 * `UNSAFE_COMP` is enabled in "Makefile" --- not on by default, because
   the core and base layers are not yet good enough.

   Effectiveness: Matters the most for "core.so", which has its own
   setting, but otherwise affects a from-source `racket/base` expansion
   by about 5%.

 * `CORE_UNSAFE_COMP` is enabled in "Makefile" --- applies to "core.so"
   even if `UNSAFE_COMP` is disabled.

   Effectiveness: Can mean a 10-20% improvement in loading
   `racket/base` from source.

 * `compile-as-independent?` is #f in "linklet.sls" --- not set to #f
   currently, because it causes compiled files for Racket modules to
   be incompatible with any change or rebuilding of the core and base
   layers.

   Effectiveness: Little effect on tasks like loading `racket/base`
   from source, but substantial effects on programs where the Chez
   Scheme optimizer needs to recognize uses of primitives (e.g.,
   microbenchmarks).

 * `make strip` run --- strips away inspector information to make the
   core and base layers load more quickly, but with the loss of
   backtrace information.

   Effectivess: Cuts the load time for the core and base layers by
   30-50%.
